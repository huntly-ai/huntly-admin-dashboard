{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///Users/felipesantos/Documents/Huntly/huntly-admin-dashboard/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from '@prisma/client'\n\nconst globalForPrisma = globalThis as unknown as {\n  prisma: PrismaClient | undefined\n}\n\nexport const prisma = globalForPrisma.prisma ?? new PrismaClient()\n\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma\n\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM,kBAAkB;AAIjB,MAAM,SAAS,gBAAgB,MAAM,IAAI,IAAI,6IAAY;AAEhE,wCAA2C,gBAAgB,MAAM,GAAG","debugId":null}},
    {"offset": {"line": 65, "column": 0}, "map": {"version":3,"sources":["file:///Users/felipesantos/Documents/Huntly/huntly-admin-dashboard/app/api/financeiro/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\"\nimport { prisma } from \"@/lib/prisma\"\nimport { TransactionType, TransactionCategory } from \"@prisma/client\"\n\nexport async function GET(request: NextRequest) {\n  try {\n    const searchParams = request.nextUrl.searchParams\n    const type = searchParams.get(\"type\")\n    const category = searchParams.get(\"category\")\n    const startDate = searchParams.get(\"startDate\")\n    const endDate = searchParams.get(\"endDate\")\n    \n    const transactions = await prisma.transaction.findMany({\n      where: {\n        ...(type && { type: type as TransactionType }),\n        ...(category && { category: category as TransactionCategory }),\n        ...(startDate && endDate && {\n          date: {\n            gte: new Date(startDate),\n            lte: new Date(endDate),\n          },\n        }),\n      },\n      orderBy: {\n        date: \"desc\",\n      },\n      include: {\n        client: {\n          select: {\n            id: true,\n            name: true,\n          },\n        },\n        project: {\n          select: {\n            id: true,\n            name: true,\n          },\n        },\n      },\n    })\n\n    return NextResponse.json(transactions)\n  } catch (error) {\n    console.error(\"Error fetching transactions:\", error)\n    return NextResponse.json(\n      { error: \"Failed to fetch transactions\" },\n      { status: 500 }\n    )\n  }\n}\n\nexport async function POST(request: NextRequest) {\n  try {\n    const body = await request.json()\n    \n    const transaction = await prisma.transaction.create({\n      data: {\n        type: body.type,\n        category: body.category,\n        amount: parseFloat(body.amount),\n        description: body.description,\n        date: body.date ? new Date(body.date) : new Date(),\n        projectId: body.projectId || null,\n        clientId: body.clientId || null,\n        invoiceNumber: body.invoiceNumber,\n        paymentMethod: body.paymentMethod,\n        notes: body.notes,\n      },\n      include: {\n        client: {\n          select: {\n            id: true,\n            name: true,\n          },\n        },\n        project: {\n          select: {\n            id: true,\n            name: true,\n          },\n        },\n      },\n    })\n\n    // Update project actual cost if it's a project-related expense\n    if (body.projectId && body.type === \"EXPENSE\") {\n      const project = await prisma.project.findUnique({\n        where: { id: body.projectId },\n      })\n      if (project) {\n        await prisma.project.update({\n          where: { id: body.projectId },\n          data: {\n            actualCost: project.actualCost + parseFloat(body.amount),\n          },\n        })\n      }\n    }\n\n    return NextResponse.json(transaction, { status: 201 })\n  } catch (error: unknown) {\n    console.error(\"Error creating transaction:\", error)\n    const prismaError = error as { code?: string }\n    \n    if (prismaError.code === \"P2003\") {\n      return NextResponse.json(\n        { error: \"Cliente ou projeto n√£o encontrado\" },\n        { status: 400 }\n      )\n    }\n    \n    return NextResponse.json(\n      { error: \"Failed to create transaction\" },\n      { status: 500 }\n    )\n  }\n}\n\n"],"names":[],"mappings":";;;;;;AAAA;AACA;;;AAGO,eAAe,IAAI,OAAoB;IAC5C,IAAI;QACF,MAAM,eAAe,QAAQ,OAAO,CAAC,YAAY;QACjD,MAAM,OAAO,aAAa,GAAG,CAAC;QAC9B,MAAM,WAAW,aAAa,GAAG,CAAC;QAClC,MAAM,YAAY,aAAa,GAAG,CAAC;QACnC,MAAM,UAAU,aAAa,GAAG,CAAC;QAEjC,MAAM,eAAe,MAAM,yHAAM,CAAC,WAAW,CAAC,QAAQ,CAAC;YACrD,OAAO;gBACL,GAAI,QAAQ;oBAAE,MAAM;gBAAwB,CAAC;gBAC7C,GAAI,YAAY;oBAAE,UAAU;gBAAgC,CAAC;gBAC7D,GAAI,aAAa,WAAW;oBAC1B,MAAM;wBACJ,KAAK,IAAI,KAAK;wBACd,KAAK,IAAI,KAAK;oBAChB;gBACF,CAAC;YACH;YACA,SAAS;gBACP,MAAM;YACR;YACA,SAAS;gBACP,QAAQ;oBACN,QAAQ;wBACN,IAAI;wBACJ,MAAM;oBACR;gBACF;gBACA,SAAS;oBACP,QAAQ;wBACN,IAAI;wBACJ,MAAM;oBACR;gBACF;YACF;QACF;QAEA,OAAO,gJAAY,CAAC,IAAI,CAAC;IAC3B,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,gCAAgC;QAC9C,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAA+B,GACxC;YAAE,QAAQ;QAAI;IAElB;AACF;AAEO,eAAe,KAAK,OAAoB;IAC7C,IAAI;QACF,MAAM,OAAO,MAAM,QAAQ,IAAI;QAE/B,MAAM,cAAc,MAAM,yHAAM,CAAC,WAAW,CAAC,MAAM,CAAC;YAClD,MAAM;gBACJ,MAAM,KAAK,IAAI;gBACf,UAAU,KAAK,QAAQ;gBACvB,QAAQ,WAAW,KAAK,MAAM;gBAC9B,aAAa,KAAK,WAAW;gBAC7B,MAAM,KAAK,IAAI,GAAG,IAAI,KAAK,KAAK,IAAI,IAAI,IAAI;gBAC5C,WAAW,KAAK,SAAS,IAAI;gBAC7B,UAAU,KAAK,QAAQ,IAAI;gBAC3B,eAAe,KAAK,aAAa;gBACjC,eAAe,KAAK,aAAa;gBACjC,OAAO,KAAK,KAAK;YACnB;YACA,SAAS;gBACP,QAAQ;oBACN,QAAQ;wBACN,IAAI;wBACJ,MAAM;oBACR;gBACF;gBACA,SAAS;oBACP,QAAQ;wBACN,IAAI;wBACJ,MAAM;oBACR;gBACF;YACF;QACF;QAEA,+DAA+D;QAC/D,IAAI,KAAK,SAAS,IAAI,KAAK,IAAI,KAAK,WAAW;YAC7C,MAAM,UAAU,MAAM,yHAAM,CAAC,OAAO,CAAC,UAAU,CAAC;gBAC9C,OAAO;oBAAE,IAAI,KAAK,SAAS;gBAAC;YAC9B;YACA,IAAI,SAAS;gBACX,MAAM,yHAAM,CAAC,OAAO,CAAC,MAAM,CAAC;oBAC1B,OAAO;wBAAE,IAAI,KAAK,SAAS;oBAAC;oBAC5B,MAAM;wBACJ,YAAY,QAAQ,UAAU,GAAG,WAAW,KAAK,MAAM;oBACzD;gBACF;YACF;QACF;QAEA,OAAO,gJAAY,CAAC,IAAI,CAAC,aAAa;YAAE,QAAQ;QAAI;IACtD,EAAE,OAAO,OAAgB;QACvB,QAAQ,KAAK,CAAC,+BAA+B;QAC7C,MAAM,cAAc;QAEpB,IAAI,YAAY,IAAI,KAAK,SAAS;YAChC,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAAoC,GAC7C;gBAAE,QAAQ;YAAI;QAElB;QAEA,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAA+B,GACxC;YAAE,QAAQ;QAAI;IAElB;AACF","debugId":null}}]
}